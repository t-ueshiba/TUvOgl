module OpenHRP
{
  /**
   * @brief service to generate reaching motions
   * 
   * This service can be used in the following procedure
   * -# (optional) call setGraspCenter() to set the origin of the grasping coordinates. If not called, (0,0,0) is used.
   * -# call selectArm() to select arm used for reaching.
   * -# call selectTaskDofs() to select DOFs controlled by tasks and set weights for those dofs.
   * -# (optional) call selectExecutionMode() to select an execution mode.
   *    If selectExecutionMode() is not called, a mode "IMMEDIATELY" is used.
   * -# call setTargetPose() to set the reaching target pose. 
   * -# call generateMotion() to generate a reaching motion. If the execution mode is IMMEDIATELY, the robot start to reach the target immediately, If not, a generated pattern is executed when playPattern() is called.
   * -# go back to the previous step or call goRestPosture() to back to the rest posture.
   */
  interface ReachingService
  {
    typedef sequence<boolean> bsequence;
    typedef sequence<double> dsequence;

    struct  state{
      dsequence q;    ///< array of joint angles
      dsequence p;    ///< position of the base link
      dsequence rpy;  ///< RPY angles of the base link
      dsequence zmp;  ///< ZMP
    };

    typedef sequence<state> motion;

    /**
     * @brief arm
     */
    enum arm {
      RIGHT_ARM, ///< right arm 
      LEFT_ARM   ///< left arm
    };

    /**
     * @brief execution mode
     */
    enum executionMode {
      IMMEDIATELY, ///< pattern is generated and executed simultaneously
      LATER        ///< generated pattern is executed by calling playPattern()
    };

    /**
     * @brief select an arm used to reach the target
     * @param i_arm arm
     * @return true if selected successfully, false otherwise
     */
    boolean selectArm(in arm i_arm);

    /**
     * @brief deselect an arm used to reach the target
     * @param i_arm arm
     * @return true if deselected successfully, false otherwise
     */
    boolean deselectArm(in arm i_arm);

    /**
     * @brief check if the arm is selected or not
     * @param i_arm arm
     * @return true if selected, false otherwise
     */
    boolean isSelected(in arm i_arm);

    /**
     * @brief check if the arm is master or slave
     * @param i_arm arm
     * @return true if the arm is master, false otherwise
     */
    boolean isMaster(in arm i_arm);

    /**
     * @brief set the origin of the grasping coordinates
     * @param i_arm arm
     * @param pos position relative to the wrist joint
     * @return true if set successfully, false otherwise
     */
    boolean setGraspCenter(in arm i_arm, in dsequence pos);

    /**
     * @brief select joints used to generate reaching motions
     * @param used sequence of true(used) or false(not used). The length must be the number of joints + 6(dofs of free-flayer joint).
     * @return true if selected successfully, false otherwise
     */
    boolean selectUsedDofs(in bsequence used);

    /**
     * @brief select DOFs controlled by tasks
     * @param i_arm arm
     * @param constrained sequence of true(constrained) or false(not constrained). The length must be 6.
     * @param weights sequence of weights 
     * @return true if selected successfully, false otherwise
     */
    boolean selectTaskDofs(in arm i_arm, in bsequence constrained, in dsequence weights);

    /**
     * @brief select an execution mode
     * @param mode an execution mode
     * @return true if selected successfully, false otherwise
     */
    boolean selectExecutionMode(in executionMode mode);

    /**
     * @brief set target pose of the grasp coodinates
     * @param i_arm arm
     * @param pose homogeneous matrix of the grasp coordinates in the global coordinates.
     * @param time time to reach the target
     * @return true if set successfully, false otherwise
     */
    boolean setTargetPose(in arm i_arm, in dsequence pose, in double time);

    /**
     * @brief set target arc motion of the grasp coodinates
     * @param i_arm arm
     * @param rotation rotation matrix of the grasp coordinates in the global coordinates.
     * @param center center of rotation
     * @param axis axis of rotation
     * @param th angle of rotation
     * @param time time to reach the target
     * @return true if set successfully, false otherwise
     */
    boolean setTargetArc(in arm i_arm, in dsequence rotation, 
			 in dsequence center, in dsequence axis, 
			 in double th, in double time);

    /**
     * @brief set target velocity of the grasp coodinates
     @ @param i_arm arm
     * @param vel linear and angular velocities of the grasp coordinates in the global coordinates(length must be 6).
     * @param time time to keep the velocity
     * @return true if set successfully, false otherwise
     */
    boolean setTargetVelocity(in arm i_arm, in dsequence vel, in double time);

    /**
     * @brief get target pose of the grasp coodinates
     @ @param i_arm arm
     * @param pose homogeneous matrix of the grasp coordinates in the global coordinates.
     * @return true if gotten successfully, false otherwise
     */
    boolean getCurrentPose(in arm i_arm, out dsequence pose);

    /**
     * @brief playback a generated motion
     * @return true if played successfully, false otherwise
     */
    boolean playMotion();

    /**
     * @brief go back to the rest posture
     */
    boolean goRestPosture();

    /**
     * @brief get motion
     */
    motion getMotion();

    /**
     * @brief generate a motion
     */
    void generateMotion();

    /**
     * @brief reverse rotation direction
     * @param i_arm arm
     */
    void reverseRotation(in arm i_arm);

    /**
     * @brief enable/disable relative position constraint
     * @param flag enable/disable
     */
    void enableRelativePositionConstraint(in boolean flag);

    /**
     * @brief enable/disable gaze constraint
     * @param flag enable/disable
     */
    void enableGazeConstraint(in boolean flag);
  };
};
